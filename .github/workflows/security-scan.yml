name: Fix security vulnerabilities with AI

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  security-events: write

jobs:
  vulnerability-detection:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      security-events: write
    
    outputs:
      vulnerabilities-found: ${{ steps.extract_vulns.outputs.fixable_count }}
      has-vulnerabilities: ${{ steps.extract_vulns.outputs.fixable_count > 0 }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Install Snyk CLI
        run: npm install -g snyk

      - name: Authenticate Snyk
        run: snyk auth ${{ secrets.SNYK_TOKEN }}
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: Run Snyk vulnerability scan
        run: snyk test --json > full-scan-results.json || true

      - name: Extract high-risk vulnerabilities and generate summary
        run: |
          echo "INFO: Starting vulnerability data extraction and processing"
          
          # Check if scan results exist and are valid
          if [ ! -f "full-scan-results.json" ] || [ ! -s "full-scan-results.json" ]; then
            echo "WARNING: No scan results found, creating empty vulnerability dataset"
            echo '{"vulnerabilities": []}' > full-scan-results.json
          fi
          
          # Extract high and critical vulnerabilities for display
          echo "INFO: Extracting high-risk vulnerabilities"
          jq '.vulnerabilities[] | select(.severity == "high" or .severity == "critical") | {title: .title, severity: .severity, package: .packageName, version: .version, identifiers: .identifiers}' full-scan-results.json || echo "No high/critical vulnerabilities found"
          
          # Generate vulnerability summary
          echo "## Snyk Vulnerability Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Scan Date:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          HIGH_COUNT=$(jq '[.vulnerabilities[] | select(.severity == "high")] | length' full-scan-results.json 2>/dev/null || echo "0")
          CRITICAL_COUNT=$(jq '[.vulnerabilities[] | select(.severity == "critical")] | length' full-scan-results.json 2>/dev/null || echo "0")
          
          echo "**Critical Vulnerabilities:** $CRITICAL_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "**High Vulnerabilities:** $HIGH_COUNT" >> $GITHUB_STEP_SUMMARY
          
          # Also create the high-severity filtered results for backwards compatibility
          jq '.vulnerabilities[] | select(.severity == "high" or .severity == "critical")' full-scan-results.json > snyk-results.json || echo "[]" > snyk-results.json

      - name: Extract fixable vulnerabilities
        id: extract_vulns
        run: |
          echo "INFO: Processing vulnerability data for fixable issues"
          
          echo "INFO: Filtering high and critical severity vulnerabilities"
          jq -c '.vulnerabilities[]? // [] | select(.severity == "high" or .severity == "critical") | {
            id: (.id // "unknown"),
            title: (.title // "Unknown Vulnerability"),
            severity: (.severity // "unknown"),
            packageName: (.packageName // "unknown"),
            version: (.version // "unknown"),
            nearestFixedInVersion: (.nearestFixedInVersion // null),
            isUpgradable: (.isUpgradable // false),
            isPatchable: (.isPatchable // false),
            upgradePath: (.upgradePath // []),
            description: (.description // "No description available"),
            references: (.references // []),
            CVSSv3: (.CVSSv3 // null),
            from: (.from // [])
          }' full-scan-results.json 2>/dev/null | jq -s '.' > detailed-vulnerabilities.json || echo "[]" > detailed-vulnerabilities.json
          
          VULN_COUNT=$(jq 'length' detailed-vulnerabilities.json 2>/dev/null | head -n 1 | tr -d '\n\r' || echo "0")
          
          if ! [[ "$VULN_COUNT" =~ ^[0-9]+$ ]]; then
            echo "WARNING: Invalid vulnerability count detected, setting to 0"
            VULN_COUNT=0
          fi
          echo "fixable_count=$VULN_COUNT" >> $GITHUB_OUTPUT
          echo "INFO: Identified $VULN_COUNT high/critical vulnerabilities requiring attention"
          
          echo "INFO: Generating comprehensive vulnerability analysis report"
          echo "# Security Vulnerability Analysis Report" > vulnerability-context.md
          echo "" >> vulnerability-context.md
          echo "**Project:** ${{ github.repository }}" >> vulnerability-context.md
          echo "**Scan Date:** $(date)" >> vulnerability-context.md
          echo "**Total High/Critical Vulnerabilities:** $VULN_COUNT" >> vulnerability-context.md
          echo "" >> vulnerability-context.md
          
          echo "## Detected Vulnerabilities" >> vulnerability-context.md
          echo "" >> vulnerability-context.md
          
          if [ "$VULN_COUNT" -gt 0 ] 2>/dev/null; then
            echo "INFO: Processing detailed vulnerability information for $VULN_COUNT vulnerabilities"
            jq -r '.[] | "### \(.title // "Unknown Vulnerability") (\(.severity // "unknown" | ascii_upcase))
            
            **Package:** \(.packageName // "unknown")@\(.version // "unknown")
            **CVE ID:** \(.id // "N/A")
            **CVSS Score:** \(.CVSSv3 // "N/A")
            **Current Version:** \(.version // "unknown")
            **Fixed In:** \(.nearestFixedInVersion // "No direct fix available")
            **Upgradable:** \(.isUpgradable // false)
            **Patchable:** \(.isPatchable // false)
            **Dependency Path:** \(if .from then (.from | if type == "array" then join(" → ") else tostring end) else "Direct dependency" end)
            
            **Description:** \(.description // "No description available")
            
            **References:**
            \(if .references then 
              (if (.references | type) == "array" then 
                (.references | map("- \(.)") | join("\n")) 
              else 
                "- \(.references)" 
              end) 
            else 
              "No references available" 
            end)
            
            ---
            "' detailed-vulnerabilities.json >> vulnerability-context.md 2>/dev/null || echo "ERROR: Failed to process vulnerability details" >> vulnerability-context.md
          else
            echo "INFO: No high or critical vulnerabilities detected in this scan"
            echo "No high or critical vulnerabilities detected." >> vulnerability-context.md
            echo "" >> vulnerability-context.md
            echo "STATUS: This project appears to be secure from high and critical vulnerabilities." >> vulnerability-context.md
          fi
          echo "SUCCESS: Vulnerability analysis and report generation completed"

      - name: Upload vulnerability artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: vulnerability-data
          path: |
            full-scan-results.json
            detailed-vulnerabilities.json
            vulnerability-context.md
            snyk-results.json

  create-vulnerability-issue:
    runs-on: ubuntu-latest
    needs: vulnerability-detection
    if: needs.vulnerability-detection.outputs.has-vulnerabilities == 'true'
    
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download vulnerability data
        uses: actions/download-artifact@v4
        with:
          name: vulnerability-data
          path: vulnerability-data/

      - name: Create consolidated vulnerability issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const fs = require('fs');
            
            console.log('INFO: Initializing vulnerability issue creation process');
            
            const labelsToCreate = [
              { name: 'security', description: 'Security vulnerability', color: 'd73a4a' },
              { name: 'vulnerability', description: 'Security vulnerability found by scan', color: 'b60205' },
              { name: 'high-priority', description: 'High priority issue', color: 'ff6b6b' },
              { name: 'critical', description: 'Critical severity issue', color: 'd10000' },
              { name: 'ai-fix-requested', description: 'AI assistance requested for fix', color: '0052cc' },
              { name: 'copilot-task', description: 'Task assigned to GitHub Copilot', color: '0366d6' },
              { name: 'scheduled', description: 'Automatically scheduled task', color: '7057ff' }
            ];
            
            console.log('INFO: Creating required labels for security issue tracking');
            for (const label of labelsToCreate) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ...label
                });
                console.log(`INFO: Successfully created label: ${label.name}`);
              } catch (error) {
                if (error.status !== 422) {
                  console.log(`WARNING: Could not create label ${label.name}: ${error.message}`);
                } else {
                  console.log(`INFO: Label ${label.name} already exists`);
                }
              }
            }
            
            console.log('INFO: Checking for vulnerability data file');
            if (!fs.existsSync('vulnerability-data/detailed-vulnerabilities.json')) {
              console.log('WARNING: No vulnerability data file found, skipping issue creation');
              return;
            }
            
            console.log('INFO: Reading vulnerability data from scan results');
            const vulnData = JSON.parse(fs.readFileSync('vulnerability-data/detailed-vulnerabilities.json', 'utf8'));
            const vulnCount = vulnData.length;
            
            console.log(`INFO: Found ${vulnCount} vulnerabilities to process`);
            if (vulnCount === 0) {
              console.log('INFO: No vulnerabilities detected, skipping issue creation');
              return;
            }
            
            console.log('INFO: Building comprehensive vulnerability issue body');
            let issueBody = `# Security Vulnerability Analysis Report\n\n`;
            issueBody += `**Repository:** ${{ github.repository }}\n`;
            issueBody += `**Scan Date:** ${new Date().toISOString()}\n`;
            issueBody += `**Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n`;
            issueBody += `**Total Vulnerabilities:** ${vulnCount}\n\n`;
            
            issueBody += `## Detected Vulnerabilities\n\n`;
            
            console.log('INFO: Processing individual vulnerability details for issue body');
            for (const vuln of vulnData) {
              const vulnId = vuln.id || 'unknown';
              const vulnTitle = vuln.title || 'Unknown Vulnerability';
              const severity = (vuln.severity || 'unknown').toUpperCase();
              const packageName = vuln.packageName || 'unknown';
              const version = vuln.version || 'unknown';
              const fixedVersion = vuln.nearestFixedInVersion || 'No direct fix available';
              const description = vuln.description || 'No description available';
              const isUpgradable = vuln.isUpgradable || false;
              const isPatchable = vuln.isPatchable || false;
              const cvssScore = vuln.CVSSv3 || 'N/A';
              const dependencyPath = Array.isArray(vuln.from) ? vuln.from.join(' → ') : 'Direct dependency';
              
              issueBody += `### ${vulnTitle} in ${packageName}@${version} (${severity})\n\n`;
              issueBody += `**Package:** \`${packageName}@${version}\`\n`;
              issueBody += `**CVE ID:** ${vulnId}\n`;
              issueBody += `**CVSS Score:** ${cvssScore}\n`;
              issueBody += `**Fixed In:** \`${fixedVersion}\`\n`;
              issueBody += `**Upgradable:** ${isUpgradable}\n`;
              issueBody += `**Patchable:** ${isPatchable}\n`;
              issueBody += `**Dependency Path:** ${dependencyPath}\n\n`;
              issueBody += `**Description:** ${description}\n\n`;
              issueBody += `**Fix Command Needed:**\n`;
              issueBody += `\`\`\`bash\n`;
              if (isUpgradable && fixedVersion !== 'No direct fix available') {
                issueBody += `npm install ${packageName}@${fixedVersion}\n`;
              } else {
                issueBody += `npm update ${packageName}\n`;
              }
              issueBody += `\`\`\`\n\n`;
              issueBody += `---\n\n`;
            }
            
            issueBody += `## Action Items\n\n`;
            issueBody += `- [ ] Review all detected vulnerabilities\n`;
            issueBody += `- [ ] Prioritize critical and high severity vulnerabilities\n`;
            issueBody += `- [ ] Apply fixes suggested by GitHub Copilot\n`;
            issueBody += `- [ ] Test fixes in development environment\n`;
            issueBody += `- [ ] Deploy fixes to production\n\n`;
            
            issueBody += `## GitHub Copilot Assistance Request\n\n`;
            issueBody += `@github-copilot please analyze and fix the ${vulnCount} security vulnerabilities detected in this scan:\n\n`;
            issueBody += `### Primary Objectives:\n`;
            issueBody += `1. **Immediate Fixes:** Provide specific npm/yarn commands for each vulnerability\n`;
            issueBody += `2. **Risk Assessment:** Evaluate the security impact of each vulnerability\n`;
            issueBody += `3. **Compatibility Analysis:** Check for breaking changes in proposed fixes\n`;
            issueBody += `4. **Testing Strategy:** Recommend verification steps for each fix\n`;
            issueBody += `5. **Alternative Solutions:** Suggest alternatives if direct updates aren't safe\n\n`;
            
            issueBody += `*This issue was automatically created by the AI Security Scan workflow on ${new Date().toISOString()}*\n`;
            issueBody += `*Scan run: ${{ github.run_id }}*\n`;
            
            const labels = ['security', 'vulnerability', 'ai-fix-requested', 'copilot-task', 'scheduled'];
            const hasCritical = vulnData.some(v => v.severity === 'critical');
            const hasHigh = vulnData.some(v => v.severity === 'high');
            
            if (hasCritical) {
              labels.push('critical', 'high-priority');
            } else if (hasHigh) {
              labels.push('high-priority');
            }
            
            const issueTitle = `Security Vulnerability Scan - ${new Date().toISOString().split('T')[0]} - ${vulnCount} vulnerabilities found`;
            
            console.log('INFO: Creating GitHub issue for security vulnerabilities');
            try {
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: labels
              });
              
              console.log(`SUCCESS: Created security vulnerability issue #${issue.data.number}`);
              const issueNumber = issue.data.number;
              
              console.log('INFO: Attempting to assign issue to GitHub Copilot SWE agent');
              try {
                const suggestedActorsQuery = `
                  query($owner: String!, $repo: String!) {
                    repository(owner: $owner, name: $repo) {
                      suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                        nodes {
                          login
                          __typename
                          ... on Bot {
                            id
                          }
                          ... on User {
                            id
                          }
                        }
                      }
                    }
                  }
                `;
                
                const actorsResult = await github.graphql(suggestedActorsQuery, {
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                const copilotActor = actorsResult.repository.suggestedActors.nodes.find(
                  node => node.login === 'copilot-swe-agent'
                );
                
                if (copilotActor) {
                  console.log(`INFO: Found GitHub Copilot SWE agent with ID: ${copilotActor.id}`);
                  const issueQuery = `
                    query($owner: String!, $repo: String!, $issueNumber: Int!) {
                      repository(owner: $owner, name: $repo) {
                        issue(number: $issueNumber) {
                          id
                        }
                      }
                    }
                  `;
                  
                  const issueResult = await github.graphql(issueQuery, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issueNumber: issueNumber
                  });
                  
                  const assignMutation = `
                    mutation($issueId: ID!, $actorId: ID!) {
                      replaceActorsForAssignable(input: {assignableId: $issueId, actorIds: [$actorId]}) {
                        assignable {
                          ... on Issue {
                            id
                            title
                            assignees(first: 10) {
                              nodes {
                                login
                              }
                            }
                          }
                        }
                      }
                    }
                  `;
                  
                  await github.graphql(assignMutation, {
                    issueId: issueResult.repository.issue.id,
                    actorId: copilotActor.id
                  });
                  
                  console.log(`SUCCESS: Assigned issue #${issueNumber} to GitHub Copilot SWE agent`);
                } else {
                  console.log('WARNING: GitHub Copilot SWE agent not found or not available for assignment');
                }
              } catch (assignError) {
                console.log(`WARNING: Failed to assign issue to Copilot: ${assignError.message}`);
              }
              
              console.log('INFO: Attempting to pin the security issue');
              try {
                await github.graphql(`
                  mutation($issueId: ID!) {
                    pinIssue(input: {issueId: $issueId}) {
                      issue {
                        id
                      }
                    }
                  }
                `, {
                  issueId: issue.data.node_id
                });
                console.log('SUCCESS: Pinned security vulnerability issue for visibility');
              } catch (pinError) {
                console.log(`WARNING: Could not pin issue (may lack permissions): ${pinError.message}`);
              }
              
              console.log('SUCCESS: Completed vulnerability issue creation and setup');
            } catch (error) {
              console.error('ERROR: Failed to create consolidated vulnerability issue:', error);
              throw error;
            }

      - name: Issue creation summary
        if: always()
        run: |
          VULN_COUNT=$(jq 'length' vulnerability-data/detailed-vulnerabilities.json 2>/dev/null || echo "0")
          
          echo "## GitHub Security Issue Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Vulnerabilities Found:** $VULN_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "**Issue Creation Date:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### GitHub Copilot Integration" >> $GITHUB_STEP_SUMMARY
          echo "The security vulnerability issue includes:" >> $GITHUB_STEP_SUMMARY
          echo "- **Automatic Assignment:** Issue assigned to GitHub Copilot SWE agent" >> $GITHUB_STEP_SUMMARY
          echo "- **Specific Fix Requests:** Detailed Copilot assistance requests" >> $GITHUB_STEP_SUMMARY
          echo "- **Actionable Tasks:** Clear requirements for fix commands" >> $GITHUB_STEP_SUMMARY
          echo "- **Vulnerability Analysis:** Comprehensive security context" >> $GITHUB_STEP_SUMMARY
          echo "- **Priority Classification:** Critical/High priority labeling" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Labels Applied:** \`security\`, \`vulnerability\`, \`ai-fix-requested\`, \`copilot-task\`, \`scheduled\`" >> $GITHUB_STEP_SUMMARY
          echo "**Priority Labels:** \`critical\`, \`high-priority\` (based on severity)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Consolidated Report" >> $GITHUB_STEP_SUMMARY
          echo "A single consolidated vulnerability report issue has been created with:" >> $GITHUB_STEP_SUMMARY
          echo "- Complete vulnerability analysis for Copilot review" >> $GITHUB_STEP_SUMMARY
          echo "- Automatic assignment to GitHub Copilot SWE agent" >> $GITHUB_STEP_SUMMARY
          echo "- Comprehensive fix request with specific objectives" >> $GITHUB_STEP_SUMMARY
          echo "- Expected response format and priority classification" >> $GITHUB_STEP_SUMMARY
