name: Fix security vulnerabilities with AI

on:
  # Trigger on cron schedule (runs daily at 2 AM UTC)
  schedule:
    - cron: '0 2 * * *'
  
  # Trigger on pull requests
  pull_request:
    branches:
      - main
  
  # Trigger when code is merged to main
  push:
    branches:
      - main

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  security-events: write

jobs:
  vulnerability-detection:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      security-events: write
    
    outputs:
      vulnerabilities-found: ${{ steps.extract_vulns.outputs.fixable_count }}
      has-vulnerabilities: ${{ steps.extract_vulns.outputs.fixable_count > 0 }}
    
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Set up Node.js (adjust version as needed for your project)
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Step 3: Install dependencies
      - name: Install dependencies
        run: npm ci

      # Step 4: Install Snyk CLI
      - name: Install Snyk CLI
        run: npm install -g snyk

      # Step 5: Authenticate with Snyk
      - name: Authenticate Snyk
        run: snyk auth ${{ secrets.SNYK_TOKEN }}
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      # Step 6: Run Snyk vulnerability scan
      - name: Run Snyk vulnerability scan
        run: snyk test --json --severity-threshold=high > snyk-results.json || true

      # Step 7: Filter and display high-risk vulnerabilities
      - name: Extract high-risk vulnerabilities
        run: |
          echo "=== HIGH RISK VULNERABILITIES ==="
          snyk test --severity-threshold=high --json | jq '.vulnerabilities[] | select(.severity == "high" or .severity == "critical") | {title: .title, severity: .severity, package: .packageName, version: .version, identifiers: .identifiers}'

      # Step 8: Generate summary report of high-risk issues
      - name: Generate vulnerability summary
        run: |
          echo "## Snyk Vulnerability Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Scan Date:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          HIGH_COUNT=$(snyk test --json 2>/dev/null | jq '[.vulnerabilities[] | select(.severity == "high")] | length' || echo "0")
          CRITICAL_COUNT=$(snyk test --json 2>/dev/null | jq '[.vulnerabilities[] | select(.severity == "critical")] | length' || echo "0")
          
          echo "**Critical Vulnerabilities:** $CRITICAL_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "**High Vulnerabilities:** $HIGH_COUNT" >> $GITHUB_STEP_SUMMARY

      # Step 9: Parse and extract vulnerabilities for GitHub Copilot processing
      - name: Extract fixable vulnerabilities
        id: extract_vulns
        run: |
          # Create a detailed vulnerability report
          echo "Creating detailed vulnerability report..."
          snyk test --json > full-scan-results.json || true
          
          # Check if we have scan results
          if [ ! -f "full-scan-results.json" ] || [ ! -s "full-scan-results.json" ]; then
            echo "No scan results found, creating empty results"
            echo '{"vulnerabilities": []}' > full-scan-results.json
          fi
          
          # Debug: Show structure of scan results
          echo "Scan results structure:"
          jq -r 'keys' full-scan-results.json 2>/dev/null || echo "Invalid JSON in scan results"
          
          # Extract high and critical vulnerabilities with detailed context
          echo "Extracting vulnerabilities..."
          jq -c '.vulnerabilities[]? // [] | select(.severity == "high" or .severity == "critical") | {
            id: (.id // "unknown"),
            title: (.title // "Unknown Vulnerability"),
            severity: (.severity // "unknown"),
            packageName: (.packageName // "unknown"),
            version: (.version // "unknown"),
            nearestFixedInVersion: (.nearestFixedInVersion // null),
            isUpgradable: (.isUpgradable // false),
            isPatchable: (.isPatchable // false),
            upgradePath: (.upgradePath // []),
            description: (.description // "No description available"),
            references: (.references // []),
            CVSSv3: (.CVSSv3 // null),
            from: (.from // [])
          }' full-scan-results.json 2>/dev/null | jq -s '.' > detailed-vulnerabilities.json || echo "[]" > detailed-vulnerabilities.json
          
          # Count vulnerabilities
          VULN_COUNT=$(jq 'length' detailed-vulnerabilities.json 2>/dev/null | head -n 1 | tr -d '\n\r' || echo "0")
          # Debug: show raw count value
          echo "Raw VULN_COUNT value: '$VULN_COUNT'"
          # Ensure it's a valid number
          if ! [[ "$VULN_COUNT" =~ ^[0-9]+$ ]]; then
            echo "Invalid vulnerability count: '$VULN_COUNT', setting to 0"
            VULN_COUNT=0
          fi
          echo "fixable_count=$VULN_COUNT" >> $GITHUB_OUTPUT
          echo "Found $VULN_COUNT high/critical vulnerabilities"
          
          # Create context file for GitHub Copilot
          echo "# Security Vulnerability Analysis Report" > vulnerability-context.md
          echo "" >> vulnerability-context.md
          echo "**Project:** ${{ github.repository }}" >> vulnerability-context.md
          echo "**Scan Date:** $(date)" >> vulnerability-context.md
          echo "**Total High/Critical Vulnerabilities:** $VULN_COUNT" >> vulnerability-context.md
          echo "" >> vulnerability-context.md
          
          # Generate detailed vulnerability descriptions for Copilot
          echo "## Detected Vulnerabilities" >> vulnerability-context.md
          echo "" >> vulnerability-context.md
          
          if [ "$VULN_COUNT" -gt 0 ] 2>/dev/null; then
            echo "Processing $VULN_COUNT vulnerabilities..."
            jq -r '.[] | "### \(.title // "Unknown Vulnerability") (\(.severity // "unknown" | ascii_upcase))
            
            **Package:** \(.packageName // "unknown")@\(.version // "unknown")
            **CVE ID:** \(.id // "N/A")
            **CVSS Score:** \(.CVSSv3 // "N/A")
            **Current Version:** \(.version // "unknown")
            **Fixed In:** \(.nearestFixedInVersion // "No direct fix available")
            **Upgradable:** \(.isUpgradable // false)
            **Patchable:** \(.isPatchable // false)
            **Dependency Path:** \(if .from then (.from | if type == "array" then join(" → ") else tostring end) else "Direct dependency" end)
            
            **Description:** \(.description // "No description available")
            
            **References:**
            \(if .references then 
              (if (.references | type) == "array" then 
                (.references | map("- \(.)") | join("\n")) 
              else 
                "- \(.references)" 
              end) 
            else 
              "No references available" 
            end)
            
            ---
            "' detailed-vulnerabilities.json >> vulnerability-context.md 2>/dev/null || echo "Error processing vulnerability details" >> vulnerability-context.md
          else
            echo "No high or critical vulnerabilities detected."
            echo "No high or critical vulnerabilities detected." >> vulnerability-context.md
            echo "" >> vulnerability-context.md
            echo "✅ This project appears to be secure from high and critical vulnerabilities!" >> vulnerability-context.md
          fi

      # Step 10: Upload vulnerability data for fix job
      - name: Upload vulnerability artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: vulnerability-data
          path: |
            full-scan-results.json
            detailed-vulnerabilities.json
            vulnerability-context.md
            snyk-results.json

      # Debug step: Show what we found
      - name: Debug vulnerability detection
        if: always()
        run: |
          echo "=== DEBUG INFORMATION ==="
          echo "Vulnerability files created:"
          ls -la *.json *.md 2>/dev/null || echo "No files found"
          echo ""
          echo "Detailed vulnerabilities content:"
          if [ -f detailed-vulnerabilities.json ]; then
            cat detailed-vulnerabilities.json | head -20
          else
            echo "detailed-vulnerabilities.json not found"
          fi
          echo ""
          echo "Vulnerability context preview:"
          if [ -f vulnerability-context.md ]; then
            head -20 vulnerability-context.md
          else
            echo "vulnerability-context.md not found"
          fi

  github-copilot-fix:
    runs-on: ubuntu-latest
    needs: vulnerability-detection
    if: needs.vulnerability-detection.outputs.has-vulnerabilities == 'true'
    
    outputs:
      package_updated: ${{ steps.apply_copilot_fixes.outputs.package_updated }}
    
    permissions:
      contents: write
      pull-requests: write
      actions: read
    
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Set up Node.js
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Step 3: Download vulnerability data
      - name: Download vulnerability data
        uses: actions/download-artifact@v4
        with:
          name: vulnerability-data
          path: vulnerability-data/

      # Step 4: Set up GitHub CLI authentication
      - name: Set up GitHub CLI authentication
        run: |
          # Clear any existing GitHub tokens from environment to avoid conflicts
          unset GITHUB_TOKEN
          unset GH_TOKEN
          # Use token directly without environment variable conflicts
          echo "${{ secrets.GH_TOKEN }}" | gh auth login --with-token

      # Step 5: Install GitHub Copilot CLI extension
      - name: Install GitHub Copilot CLI extension
        run: |
          # GitHub CLI is pre-installed in ubuntu-latest runners
          echo "Using pre-installed GitHub CLI"
          gh --version
          
          # Clear any existing GitHub tokens from environment to avoid conflicts
          unset GITHUB_TOKEN
          unset GH_TOKEN
          
          # Configure git credentials to use the token
          git config --global credential.helper store
          echo "https://x-access-token:${{ secrets.GH_TOKEN }}@github.com" > ~/.git-credentials
          
          # Try to install GitHub Copilot CLI extension
          echo "Installing GitHub Copilot CLI extension..."
          gh extension install github/gh-copilot 2>/dev/null || gh extension list | grep -q "gh-copilot"
          
          # Set up GitHub CLI authentication with proper format
          echo "Setting up GitHub CLI authentication..."
          mkdir -p ~/.config/gh
          cat > ~/.config/gh/hosts.yml << EOF
          github.com:
            oauth_token: ${{ secrets.GH_TOKEN }}
            user: ${{ github.repository_owner }}
            git_protocol: https
          EOF
          
          # Use token directly without environment variable conflicts
          echo "${{ secrets.GH_TOKEN }}" | gh auth login --with-token
          
          # Verify authentication works
          gh auth status || echo "Direct auth failed, trying alternative method"
          
          # Test Copilot CLI functionality
          if gh copilot --help >/dev/null 2>&1; then
            echo "✅ GitHub Copilot CLI is working"
          else
            echo "⚠️ GitHub Copilot CLI installed but not functional"
          fi
          
          # Debug information
          echo "=== GitHub CLI Debug Information ==="
          echo "GitHub CLI version: $(gh --version)"
          echo "Authentication status:"
          gh auth status 2>/dev/null || echo "Auth status check failed"
          echo "Available extensions:"
          gh extension list 2>/dev/null || echo "No extensions or list failed"
          echo "===================================="

      # Step 5: Analyze vulnerabilities with GitHub Copilot
      - name: Generate fixes with GitHub Copilot
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "🤖 Using GitHub Copilot to analyze and fix vulnerabilities..."

          # gh auth login --with-token < <(echo $GITHUB_TOKEN)
          
          # Create prompts for GitHub Copilot based on vulnerabilities
          cat > copilot-prompts.txt << 'EOF'
          Based on the security vulnerability report in vulnerability-data/vulnerability-context.md, please provide specific fixes for the Node.js/npm project vulnerabilities:

          1. Analyze each vulnerability and determine the best fix approach
          2. Generate specific npm commands to update vulnerable packages
          3. Identify any potential breaking changes or compatibility issues
          4. Suggest alternative packages if direct updates aren't available
          5. Provide code-level fixes if the vulnerabilities are in application code
          
          Focus on:
          - High and critical severity vulnerabilities
          - Dependency updates that maintain compatibility
          - Security best practices for Node.js applications
          - Minimal disruption to existing functionality
          EOF
          
          # Check if GitHub Copilot CLI is available and try to use it
          echo "## 🤖 AI-Powered Security Analysis" > copilot-analysis.md
          echo "" >> copilot-analysis.md
          echo "### Analysis Method Detection" >> copilot-analysis.md
          
          # Test Copilot CLI availability with better detection
          COPILOT_AVAILABLE=false
          API_AVAILABLE=false
          
          # Test if Copilot CLI is working (more thorough test)
          if gh extension list | grep -q "gh-copilot" && gh copilot --help >/dev/null 2>&1; then
            echo "✅ GitHub Copilot CLI detected and working" >> copilot-analysis.md
            COPILOT_AVAILABLE=true
          else
            echo "❌ GitHub Copilot CLI not available or not working" >> copilot-analysis.md
          fi
          
          # Test Copilot API availability
          if gh api /user/copilot/billing >/dev/null 2>&1; then
            echo "✅ GitHub Copilot API access detected" >> copilot-analysis.md
            API_AVAILABLE=true
          else
            echo "❌ GitHub Copilot API not accessible" >> copilot-analysis.md
          fi

          echo "API_AVAILABLE value: $API_AVAILABLE"

          echo "COPILOT_AVAILABLE value: $COPILOT_AVAILABLE"
          
          echo "### Vulnerability Analysis Results" >> copilot-analysis.md
          
          if [ "$COPILOT_AVAILABLE" = true ]; then
            echo "Using GitHub Copilot CLI for analysis..."
            echo "**Analysis Method:** GitHub Copilot CLI" >> copilot-analysis.md
            
            # Create a detailed prompt for Copilot with vulnerability context
            VULN_COUNT=$(jq -r 'length' vulnerability-data/detailed-vulnerabilities.json 2>/dev/null || echo "0")
            PROMPT="Fix $VULN_COUNT security vulnerabilities found by Snyk scan. Generate npm update commands for package.json vulnerabilities. Focus on upgradable packages with fixes available."
            
            echo "🤖 Generating AI-powered fixes with prompt: $PROMPT" >> copilot-analysis.md
            
            # Try using Copilot CLI with timeout and better error handling
            if timeout 60 gh copilot suggest "$PROMPT" --target shell > copilot-suggestions.txt 2>&1; then
              echo "✅ Copilot CLI analysis successful" >> copilot-analysis.md
              echo "## AI-Generated Fix Suggestions:" >> copilot-analysis.md
              echo '```bash' >> copilot-analysis.md
              cat copilot-suggestions.txt >> copilot-analysis.md
              echo '```' >> copilot-analysis.md
            else
              echo "❌ Copilot CLI analysis failed (timeout or error), falling back to rule-based analysis" >> copilot-analysis.md
              echo "Copilot Error Output:" >> copilot-analysis.md
              echo '```' >> copilot-analysis.md
              cat copilot-suggestions.txt 2>/dev/null || echo "No error output captured" >> copilot-analysis.md
              echo '```' >> copilot-analysis.md
              echo "Advanced rule-based analysis based on vulnerability data" > copilot-suggestions.txt
            fi
            
          elif [ "$API_AVAILABLE" = true ]; then
            echo "Using GitHub API for AI assistance..."
            echo "**Analysis Method:** GitHub API with AI assistance" >> copilot-analysis.md
            
            # Use GitHub API for some AI-like suggestions (this is a fallback)
            echo "AI-assisted analysis based on vulnerability patterns" > copilot-suggestions.txt
            echo "Using intelligent rule-based analysis with GitHub integration" >> copilot-analysis.md
            
          else
            echo "Using intelligent rule-based analysis..."
            echo "**Analysis Method:** Intelligent rule-based analysis" >> copilot-analysis.md
            echo "Advanced rule-based analysis based on vulnerability data and security best practices" > copilot-suggestions.txt
            echo "No GitHub Copilot access available - using comprehensive rule-based analysis" >> copilot-analysis.md
          fi
          
          # Extract actionable commands from vulnerability data
          echo "#!/bin/bash" > copilot-fixes.sh
          echo "# AI-Inspired Security Fixes" >> copilot-fixes.sh
          echo "# Generated on: $(date)" >> copilot-fixes.sh
          echo "" >> copilot-fixes.sh
          
          # Parse vulnerabilities and generate fix commands
          echo "# Backup original package files" >> copilot-fixes.sh
          echo "cp package.json package.json.backup" >> copilot-fixes.sh
          echo "cp package-lock.json package-lock.json.backup 2>/dev/null || true" >> copilot-fixes.sh
          echo "" >> copilot-fixes.sh
          
          # Generate specific npm update commands for each vulnerability (fixed jq syntax)
          echo "# Vulnerability-specific fixes:" >> copilot-fixes.sh
          jq -r '.[] | select(.isUpgradable == true) | 
            "echo \"Fixing " + (.title // "Unknown") + " in " + (.packageName // "unknown") + "...\"",
            if (.packageName | test("babel|webpack|@types|eslint|jest|test")) then
              "npm install " + (.packageName // "unknown") + "@" + (.nearestFixedInVersion // "latest") + " --save-dev"
            else
              "npm install " + (.packageName // "unknown") + "@" + (.nearestFixedInVersion // "latest") + " --save"
            end' \
            vulnerability-data/detailed-vulnerabilities.json >> copilot-fixes.sh 2>/dev/null || echo "# No upgradable vulnerabilities found" >> copilot-fixes.sh
          
          # Add common missing dev dependencies for Babel/Webpack projects
          echo "" >> copilot-fixes.sh
          echo "# Install commonly missing dev dependencies" >> copilot-fixes.sh
          echo "echo \"Installing missing dev dependencies...\"" >> copilot-fixes.sh
          echo "npm install @babel/plugin-transform-runtime @babel/runtime --save-dev --silent 2>/dev/null || true" >> copilot-fixes.sh
          
          # Add additional security improvements
          echo "" >> copilot-fixes.sh
          echo "# Run npm audit fix for additional security improvements" >> copilot-fixes.sh
          echo "npm audit fix --force || true" >> copilot-fixes.sh
          echo "" >> copilot-fixes.sh
          echo "# Update package-lock.json" >> copilot-fixes.sh
          echo "npm install --package-lock-only" >> copilot-fixes.sh
          
          chmod +x copilot-fixes.sh

      # Step 6: Apply test changes (README update instead of npm fixes)
      - name: Apply test changes for PR logic
        id: apply_copilot_fixes
        run: |
          echo "🔧 Testing PR creation logic with README update..."
          
          # Skip npm-based fixes and just update README for testing
          echo "Skipping npm-based vulnerability fixes as requested"
          
          # Update README.md with security scan information
          if [ -f README.md ]; then
            cp README.md README.md.backup
            
            # Add security scan information to README
            echo "" >> README.md
            echo "## 🔒 Security Status" >> README.md
            echo "" >> README.md
            echo "Last security scan: $(date)" >> README.md
            echo "Vulnerabilities detected: ${{ needs.vulnerability-detection.outputs.vulnerabilities-found }}" >> README.md
            echo "" >> README.md
            echo "This project uses automated security scanning to detect and address vulnerabilities." >> README.md
            echo "Security fixes are managed through AI-assisted analysis and pull requests." >> README.md
            echo "" >> README.md
            echo "> **Note**: This section was added by automated security workflow for testing PR logic." >> README.md
            
            echo "package_updated=true" >> $GITHUB_OUTPUT
            echo "✅ README.md was updated for testing PR logic"
          else
            echo "package_updated=false" >> $GITHUB_OUTPUT
            echo "ℹ️  No README.md found to update"
          fi
          
          # Generate a summary of changes
          echo "## Applied Test Changes" > applied-fixes.md
          echo "" >> applied-fixes.md
          echo "### README Changes (for testing PR logic)" >> applied-fixes.md
          if [ -f README.md.backup ]; then
            echo "\`\`\`diff" >> applied-fixes.md
            diff README.md.backup README.md >> applied-fixes.md || true
            echo "\`\`\`" >> applied-fixes.md
          fi

      # Step 7: Validate test changes (skip npm validation)
      - name: Validate test changes
        if: steps.apply_copilot_fixes.outputs.package_updated == 'true'
        run: |
          echo "🧪 Validating README update for PR testing..."
          
          # Skip npm-related validation
          echo "Skipping npm install, test, and build validation as requested"
          echo "This is a test run focusing only on PR creation logic"
          
          # Just verify the README was updated correctly
          if [ -f README.md ] && grep -q "Security Status" README.md; then
            echo "✅ README.md update successful"
          else
            echo "❌ README.md update failed"
          fi
          
          echo "Test validation complete - focusing on PR creation workflow"

      # Step 8: Upload comprehensive artifacts
      - name: Upload fix artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ai-security-fixes
          path: |
            copilot-fixes.sh
            copilot-analysis.md
            copilot-suggestions.txt
            applied-fixes.md
            package.json.backup
            vulnerability-data/

      # Step 10: Update job summary (without PR creation)
      - name: Create security fix branch and commit
        id: create_branch
        if: steps.apply_copilot_fixes.outputs.package_updated == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          # Create unique branch name
          BRANCH_NAME="ai-security-fix-$(date +%Y%m%d-%H%M%S)"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Actions (AI Security Fixes)"
          
          # Create and switch to new branch
          git checkout -b $BRANCH_NAME
          
          # Add all changed files
          git add README.md applied-fixes.md copilot-analysis.md || true
          
          # Create comprehensive commit message
          COMMIT_MSG="🤖� AI-Workflow Test: README update for PR logic testing

          Testing automated PR creation workflow with README update instead of npm fixes.
          
          This commit tests the AI workflow's ability to:
          - Detect vulnerabilities (${{ needs.vulnerability-detection.outputs.vulnerabilities-found }} found)
          - Create branches and commits
          - Generate pull requests
          
          Analysis method: Rule-based Analysis (npm fixes skipped)
          Test date: $(date)
          
          Co-authored-by: GitHub Actions <actions@github.com>"
          
          git commit -m "$COMMIT_MSG"
          
          # Push the branch
          git push origin $BRANCH_NAME
          
          # Create labels if they don't exist
          echo "Creating repository labels..."
          gh label create "testing" --description "Testing and validation changes" --color "f9c513" --force || echo "Testing label exists"
          gh label create "ai-workflow" --description "AI workflow testing and development" --color "0052cc" --force || echo "AI-workflow label exists"
          gh label create "automated" --description "Automated changes applied" --color "1d76db" --force || echo "Automated label exists"
          
          # Generate PR URL for manual creation and try automatic creation
          PR_URL="https://github.com/${{ github.repository }}/compare/main...$BRANCH_NAME?quick_pull=1"
          echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
          
          # Try to create PR using GitHub CLI (with fallback to manual)
          echo "Attempting to create pull request..."
          
          PR_TITLE="🤖� AI-Workflow Test: README update for PR logic testing ($(date +%Y-%m-%d))"
          
          # Try creating PR with GitHub CLI using simple body
          if gh pr create \
            --title "$PR_TITLE" \
            --body "🤖📝 AI-Workflow Testing - Testing automated PR creation logic with README update instead of npm fixes. This validates the workflow's ability to detect vulnerabilities and create PRs without applying actual dependency fixes." \
            --head "$BRANCH_NAME" \
            --base "main" \
            --label "testing" \
            --label "ai-workflow" \
            --label "automated" 2>/dev/null; then
            echo "✅ Pull request created successfully via GitHub CLI"
            PR_CREATED="true"
          else
            echo "⚠️ GitHub CLI PR creation failed - manual creation required"
            echo "This is expected due to GitHub Actions security restrictions"
            PR_CREATED="false"
          fi
          
          echo "PR_CREATED=$PR_CREATED" >> $GITHUB_OUTPUT
          
          echo "Branch created successfully: $BRANCH_NAME"
          if [ "$PR_CREATED" = "true" ]; then
            echo "Pull request created automatically"
          else
            echo "Manual PR creation required - link provided below"
            echo "PR URL: $PR_URL"
          fi

      # Step 7: PR Creation Summary
      - name: AI-Workflow Test Summary
        if: always()
        run: |
          echo "## 🤖📝 AI-Workflow Testing Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test Date:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Vulnerabilities Detected:** ${{ needs.vulnerability-detection.outputs.vulnerabilities-found }}" >> $GITHUB_STEP_SUMMARY
          echo "**Test Mode:** README update (npm fixes skipped)" >> $GITHUB_STEP_SUMMARY
          
          # Show detailed analysis method detection
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Analysis Method Detection" >> $GITHUB_STEP_SUMMARY
          
          if gh copilot --help >/dev/null 2>&1; then
            echo "**GitHub Copilot CLI:** ✅ Available" >> $GITHUB_STEP_SUMMARY
          else
            echo "**GitHub Copilot CLI:** ❌ Not available" >> $GITHUB_STEP_SUMMARY
          fi
          
          if gh api /user/copilot/billing >/dev/null 2>&1; then
            echo "**GitHub Copilot API:** ✅ Accessible" >> $GITHUB_STEP_SUMMARY
          else
            echo "**GitHub Copilot API:** ❌ Not accessible (may need subscription)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.create_branch.outputs.BRANCH_NAME }}" != "" ]; then
            echo "**🤖 Test Changes Applied:** ✅ Yes (README updated)" >> $GITHUB_STEP_SUMMARY
            echo "**🌿 Branch Created:** ✅ Yes (${{ steps.create_branch.outputs.BRANCH_NAME }})" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ steps.create_branch.outputs.PR_CREATED }}" = "true" ]; then
              echo "**� Pull Request:** ✅ Created automatically" >> $GITHUB_STEP_SUMMARY
            else
              echo "**📋 Pull Request:** ⚠️ Manual creation required" >> $GITHUB_STEP_SUMMARY
              echo "**�🔗 Create PR:** [Click here to create PR](${{ steps.create_branch.outputs.PR_URL }})" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "**🤖 Test Changes Applied:** ❌ No changes generated" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**📊 Artifacts:** Check 'ai-security-fixes' for detailed analysis" >> $GITHUB_STEP_SUMMARY
          
          # Add explanation about test mode
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🧪 Test Mode Information" >> $GITHUB_STEP_SUMMARY
          echo "This workflow run is in **test mode** and skips npm-based vulnerability fixes." >> $GITHUB_STEP_SUMMARY
          echo "Instead, it updates the README.md file to test the PR creation logic." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**What was tested:**" >> $GITHUB_STEP_SUMMARY
          echo "- Vulnerability detection and analysis" >> $GITHUB_STEP_SUMMARY
          echo "- Branch creation and commits" >> $GITHUB_STEP_SUMMARY
          echo "- Pull request creation workflow" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub CLI integration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🚀 Next Steps" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.create_branch.outputs.BRANCH_NAME }}" != "" ]; then
            if [ "${{ steps.create_branch.outputs.PR_CREATED }}" = "true" ]; then
              echo "1. **Review the test pull request** in the repository" >> $GITHUB_STEP_SUMMARY
              echo "2. **Verify the README changes** to confirm workflow functionality" >> $GITHUB_STEP_SUMMARY
              echo "3. **Close or merge the test PR** as appropriate" >> $GITHUB_STEP_SUMMARY
            else
              echo "1. **[Create Test Pull Request](${{ steps.create_branch.outputs.PR_URL }})** to complete the workflow test" >> $GITHUB_STEP_SUMMARY
              echo "2. **Review the changes** in the generated branch: \`${{ steps.create_branch.outputs.BRANCH_NAME }}\`" >> $GITHUB_STEP_SUMMARY
              echo "3. **Verify the README update** confirms the workflow is working" >> $GITHUB_STEP_SUMMARY
              echo "4. **Close the test PR** after verification" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Manual PR Creation Link:** ${{ steps.create_branch.outputs.PR_URL }}" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Test branch:** \`${{ steps.create_branch.outputs.BRANCH_NAME }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "No test changes were applied. Check the workflow logs for issues." >> $GITHUB_STEP_SUMMARY
          fi